<html>
	<link rel="stylesheet" type="text/css" href="../css/global.css">
	<h1>Line chart</h1>
	<style>
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.viz_controls {
	border:3px red solid;

}

</style>
	<body>
	</body>
		<div id="container">
			
		</div>
		<div id="controls">
			<span>Hor. Axis</span>
			<select id="control_hor_axis">
			</select>
			<span>Ver. Axis</span>
			<select id="control_ver_axis">
			</select>
			<span>Show gridlines</span>
			<span>Hor. Axis data type</span>
			<select>
				<option>Linear</option>
			</select>
			<span>Ver. Axis data type</span>
			<select>
				<option>Linear</option>
			</select>
			<input type="checkbox" name="">
			<button>Update</button>
		</div>

    <script src="../js/d3.min.js"></script>

	<script>
	var vizData = {};
	var vizId = null;
	window.onload = function(){
		vizId = document.location.search.split("=")[1];

		// creates the elements needed for the visualization with correct id's for usage throughout vizserve.
		initializeDocument();

		fetchData();
	}

	// Init the document for this visualization. For now assumes the presence of the parent error handler.
	// Two panels are added: error_panel for displaying any errors that my occur, and a viz_panel for the visualization itself.
	function initializeDocument(){
		var body = document.querySelector("#container");
		var fragment = document.createDocumentFragment();

		var error_panel = document.createElement("div");
		error_panel.classList = "hidden error_panel";
		error_panel.id = vizId + "_error_panel";
		fragment.appendChild(error_panel);

		var viz_panel = document.createElement("div");
		viz_panel.id = vizId + "_viz_panel";

		fragment.appendChild(viz_panel);

		body.appendChild(fragment);

	}

	function fetchData(){
		var request = new XMLHttpRequest();
		request.open('GET', parent.vizServeConfig.apiUrl + "/viz/" + vizId, true);

		request.onload = function() {
		  if (request.status >= 200 && request.status < 400) {
		    // Success!
		    vizData = JSON.parse(request.responseText);

		    populateControls();

		    drawLineGraph();
		  } else {
		    // We reached our target server, but it returned an error
		    parent.errorHandler.serverError(vizId + "_error_panel", "Could not fetch data for this visualization")
		  }
		};

		request.onerror = function() {
		  // There was a connection error of some sort
  		    parent.errorHandler.serverError(vizId + "_error_panel", "Network error, could not connect to server.")
		};

		try{
			request.send();
		} catch(e){
			parent.errorHandler.serverError(vizId + "_error_panel", "Network error, could not connect to server.")	
		}
	}

	// initial line graph drawing function, should only be used on first use.
	// assumes data has been fetched and can be found in vizData.data
	function drawLineGraph(){
		// TODO: these sizes need to be relative to the size of the iframe to prevent scrolling
		var margin = {top: 20, right: 20, bottom: 30, left: 50},
		    width = 700 - margin.left - margin.right,
		    height = 400 - margin.top - margin.bottom;

		var x = d3.scale.linear()
		    .range([0, width]);

		var y = d3.scale.linear()
		    .range([height, 0]);

		var xAxis = d3.svg.axis()
		    .scale(x)
		    .orient("bottom");

		var yAxis = d3.svg.axis()
		    .scale(y)
		    .orient("left");

		var line = d3.svg.line()
		    .x(function(d) { return x(d.x); })
		    .y(function(d) { return y(d.y); });

		var svg = d3.select("#" + vizId + "_viz_panel").append("svg")
		    .attr("width", width + margin.left + margin.right)
		    .attr("height", height + margin.top + margin.bottom)
		  .append("g")
		    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


		x.domain(d3.extent(vizData.data, function(d) { return d.x; }));
		y.domain(d3.extent(vizData.data, function(d) { return d.y; }));

		svg.append("g")
			.attr("class", "x axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis)
			.append("text")
			.attr("dy", "-.71em")
			.attr("x", 650)
			.style("text-anchor","end")
			.text("X");

		svg.append("g")
			.attr("class", "y axis")
			.call(yAxis)
			.append("text")
			.attr("transform", "rotate(-90)")
			.attr("y", 6)
			.attr("dy", ".71em")
			.style("text-anchor", "end")
			.text("y");

		svg.append("path")
			.datum(vizData.data)
			.attr("class", "line")
			.attr("d", line);
	}

	function populateControls(){
		// this function is called once data has been fetched. The idea is that the control elements should be populated with sensible values/options given the input data.
		var hor_axis_select = document.getElementById("control_hor_axis");
		var ver_axis_select = document.getElementById("control_ver_axis");

		// for both dropdowns the same axes should be available.
		var options = Object.keys(vizData.data[0]);
		console.log(options);
		var fragment = document.createDocumentFragment();
		var option;
		for (var i = options.length - 1; i >= 0; i--) {
			option = document.createElement("option");
			option.value = options[i];
			option.innerHTML = options[i];
			fragment.appendChild(option);
		}
		var fragment_copy = fragment.cloneNode(true);

		ver_axis_select.appendChild(fragment);
		hor_axis_select.appendChild(fragment_copy);


		// initializeAxisListeners();
	}

	function initializeAxisListeners(){

	}

	</script>
</html>